<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Oreki Tool">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="data:application/json;charset=utf-8,%7B%22name%22%3A%22Oreki%20Tool%22%2C%22short_name%22%3A%22Oreki%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23050505%22%2C%22theme_color%22%3A%22%23050505%22%2C%22orientation%22%3A%22portrait%22%7D">
    <meta name="theme-color" content="#050505">
    <title>Oreki_Veritified</title>
    <style>
        :root {
            --bg-color: #050505;
            --fg-color: #ffffff;
            --accent-text: #00ff00;
            --accent-color: #111111;
            --input-bg: #222222;
            --btn-bg: #003300;
            --btn-hover: #004d00;
            --btn-active: #006600;
            --danger-bg: #660000;
        }

        body {
            background-color: var(--bg-color);
            color: var(--fg-color);
            font-family: "Segoe UI", "Roboto", sans-serif;
            margin: 0;
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            display: flex;
            justify-content: center;
            min-height: 100vh;
            box-sizing: border-box;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 650px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: filter 0.3s;
            position: relative;
            z-index: 1;
            background: transparent;
            overflow: hidden;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
            animation: rgb-glow 3s linear infinite;
            padding-bottom: 60px; /* Prevent status bar from overlapping border */
            margin: auto;
        }

        /* 3D RGB Border Effect */
        .container::before {
            content: '';
            position: absolute;
            top: -150%; left: -150%;
            width: 400%; height: 400%; /* Increased size for smoother rotation */
            background: conic-gradient(
                #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080, #ff0000
            );
            animation: rotate-border 3s linear infinite;
            z-index: -3;
            filter: brightness(1.5);
        }
        .container::after {
            content: '';
            position: absolute;
            inset: 8px;
            background: #080808;
            border-radius: 14px;
            box-shadow: inset 0 0 20px rgba(0,0,0,1);
            z-index: -1;
        }
        @keyframes rotate-border {
            100% { transform: rotate(360deg); }
        }
        @keyframes rgb-glow {
            0% { box-shadow: 0 0 30px #ff0000; }
            16% { box-shadow: 0 0 30px #ffff00; }
            33% { box-shadow: 0 0 30px #00ff00; }
            50% { box-shadow: 0 0 30px #00ffff; }
            66% { box-shadow: 0 0 30px #0000ff; }
            83% { box-shadow: 0 0 30px #ff00ff; }
            100% { box-shadow: 0 0 30px #ff0000; }
        }

        /* Lightning Effect */
        .lightning-effect {
            position: absolute;
            top: -150%; left: -150%;
            width: 400%; height: 400%;
            background: conic-gradient(
                transparent 70%, 
                rgba(255, 255, 255, 0) 75%, 
                rgba(255, 255, 255, 1) 80%, 
                rgba(255, 255, 255, 0) 85%
            );
            animation: rotate-lightning 2s linear infinite, flash-trigger 1s infinite;
            z-index: -2;
            pointer-events: none;
            filter: blur(3px) brightness(3);
            mix-blend-mode: screen;
        }
        @keyframes rotate-lightning { 100% { transform: rotate(360deg); } }
        @keyframes flash-trigger {
            0%, 90% { opacity: 0; }
            92% { opacity: 1; }
            94% { opacity: 0; }
            96% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Section Frames */
        .section-frame {
            background: rgba(25, 25, 25, 0.8);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
        }

        /* Rainbow Header */
        .header {
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
        }
        .char { display: inline-block; }

        .sub-header {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        /* Input Frame */
        .input-frame {
            /* Inherits .section-frame via HTML class addition */
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input[type="text"] {
            width: 100%;
            background-color: var(--input-bg);
            border: 1px solid #444;
            color: white;
            padding: 8px;
            font-family: "Segoe UI", "Roboto", sans-serif;
            font-size: 16px;
            box-sizing: border-box;
            margin-bottom: 15px;
        }
        input[type="text"]:focus {
            outline: 1px solid var(--fg-color);
        }

        /* Toggles */
        .mode-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(20, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 0, 0.6); /* Thicker border */
            border-radius: 50px; /* Pill shape like Zalo frame */
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4), inset 0 0 10px rgba(0, 255, 0, 0.2); /* 3D Glow */
            transition: transform 0.2s;
        }
        .mode-row:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.7), inset 0 0 15px rgba(0, 255, 0, 0.3);
        }

        /* Contact Section */
        .contact-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 20px;
            border-radius: 50px;
            margin-top: 10px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.15);
        }
        .contact-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .contact-icon { width: 35px; height: 35px; border-radius: 8px; object-fit: cover; }
        .contact-text { display: flex; flex-direction: column; }
        .contact-title { font-size: 14px; font-weight: bold; color: white; }
        .contact-sub { font-size: 12px; color: #aaa; }
        .chat-btn {
            padding: 6px 12px;
            border-radius: 4px;
            text-decoration: none;
            font-size: 12px; font-weight: bold; color: white; white-space: nowrap;
        }
        .zalo-bg { background-color: #0068ff; }
        .mess-bg { background-color: #0084ff; }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #00ff00; }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Button */
        button {
            background-color: var(--btn-bg);
            color: var(--fg-color);
            border: 1px solid var(--fg-color);
            padding: 15px;
            font-family: "Segoe UI", "Roboto", sans-serif;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            width: 100%;
        }
        button:hover { background-color: var(--btn-hover); }
        button:active { background-color: var(--btn-active); color: white; }
        button:disabled { background-color: var(--danger-bg); color: #ffcccc; cursor: not-allowed; border-color: red; }

        /* Output */
        .output-frame {
            flex-grow: 1;
            min-height: 300px;
            position: relative;
        }
        #output-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
            transition: opacity 0.5s, filter 0.5s;
        }
        textarea {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            min-height: 400px;
            background-color: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(2px);
            transition: background-color 0.5s;
            color: #00ff00;
            border: none;
            font-family: "Consolas", monospace;
            font-size: 14px;
            resize: none;
            padding: 10px;
            box-sizing: border-box;
        }
        textarea:focus { outline: none; }
        
        .output-frame.has-result textarea {
            background-color: rgba(0, 0, 0, 0.8);
        }
        .output-frame.has-result #output-canvas {
            opacity: 0.6;
            filter: blur(1px);
        }

        .status-bar {
            font-size: 12px;
            margin-top: 15px;
            color: var(--accent-text);
            text-align: center;
            font-weight: bold;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            display: none;
        }
        .container.blurred {
            filter: blur(5px);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Background Canvas */
        #bg-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 680px) {
            body {
                padding: 15px;
                padding-top: calc(15px + env(safe-area-inset-top));
                padding-bottom: calc(50px + env(safe-area-inset-bottom));
            }
            .header {
                font-size: 22px;
            }
            .sub-header {
                font-size: 14px;
            }
            textarea {
                min-height: 300px;
                font-size: 12px;
            }
            button {
                padding: 12px;
            }
        }
    </style>
</head>
<body>

<!-- Audio Element (Hidden) -->
<!-- S·ª≠ d·ª•ng nh·∫°c n·ªÅn Cyberpunk mi·ªÖn ph√≠ b·∫£n quy·ªÅn -->
<audio id="bg-music" loop preload="auto" playsinline>
    <source src="music.mp3" type="audio/mpeg">
</audio>

<canvas id="bg-canvas"></canvas>
<div class="container">
    <div class="lightning-effect"></div>
    <div class="section-frame">
        <div class="header" id="rainbow-header"></div>
        
        <!-- Zalo Contact -->
        <div class="contact-row">
            <div class="contact-left">
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Icon_of_Zalo.svg/120px-Icon_of_Zalo.svg.png" class="contact-icon" alt="Zalo">
                <div class="contact-text">
                    <div class="contact-title">Zalo Support</div>
                    <div class="contact-sub">Admin Oreki</div>
                </div>
            </div>
            <a href="https://zalo.me/0336514635" target="_blank" class="chat-btn zalo-bg">Chat Ngay</a>
        </div>

        <!-- Messenger Contact -->
        <div class="contact-row">
            <div class="contact-left">
                <img src="https://upload.wikimedia.org/wikipedia/commons/b/be/Facebook_Messenger_logo_2020.svg" class="contact-icon" alt="Messenger">
                <div class="contact-text">
                    <div class="contact-title">H·ªó tr·ª£ Messenger</div>
                    <div class="contact-sub">Admin Oreki</div>
                </div>
            </div>
            <a href="https://www.facebook.com/share/1C5cZPPmDJ/?mibextid=wwXIfr" target="_blank" class="chat-btn mess-bg">Chat Ngay</a>
        </div>
    </div>

    <div class="input-frame section-frame">
        <div style="text-align: center; font-weight: bold; margin-bottom: 20px; color: #ffffff; text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 40px #00ff00; font-size: 24px; text-transform: uppercase; letter-spacing: 1px;">Check ƒë·ªô nh·∫°y chu·∫©n Oreki</div>
        <label>T√™n thi·∫øt b·ªã (VD: Samsung S23 Ultra; iPhone 11; Redmi Note 11;...)</label>
        <input type="text" id="device-input" placeholder="Nh·∫≠p t√™n m√°y...">
        <label>ƒê·ªô nh·∫°y hi·ªán t·∫°i (6 s·ªë ngƒÉn c√°ch b·ªüi d·∫•u "-")</label>
        <input type="text" id="current-sens" placeholder="VD: 100-100-100-100-50-50">
        <label>K√≠ch th∆∞·ªõc n√∫t b·∫Øn hi·ªán t·∫°i (10-100)</label>
        <input type="number" id="current-btn-size" placeholder="VD: 50">
    </div>

    <div class="section-frame">
        <div style="text-align: center; font-weight: bold; margin-bottom: 20px; color: #ffffff; text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; font-size: 22px; text-transform: uppercase; letter-spacing: 2px;">Hi·ªáu qu·∫£ mong mu·ªën</div>
        <div id="modes-container">
            <!-- JS will inject modes here -->
        </div>
    </div>

    <button id="analyze-btn">>>>> K√çCH HO·∫†T AI PH√ÇN T√çCH <<<<</button>

    <div class="output-frame section-frame">
        <canvas id="output-canvas"></canvas>
        <textarea id="result-text" readonly></textarea>
    </div>

    <div class="status-bar" id="status-bar">System Ready. Waiting for input...</div>
</div>

<div id="loading-overlay">
    <canvas id="loading-canvas"></canvas>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    // --- CONFIGURATION ---
    const MODES = [
        { text: "Nh·∫π T√¢m (Sensitivity)", id: "light" },
        { text: "Fix Rung (Fix Vibrate)", id: "recoil" },
        { text: "Gi·∫£m l·ªë (Reduce Overshoot)", id: "overshoot" },
        { text: "·ªîn ƒê·ªãnh (Stability)", id: "stable" },
        { text: "One Shot (Shotgun/Sniper)", id: "oneshot" },
        { text: "T·ªëi ∆∞u FPS (Buff Smooth)", id: "fps" },
        { text: "ƒê·ªì h·ªça Max (Check Graphics)", id: "graphics" }
    ];

    const VALID_BRANDS = ["iphone", "ipad", "samsung", "galaxy", "oppo", "vivo", "xiaomi", "redmi", "realme", "vsmart", "poco", "infinix", "tecno", "asus", "rog", "nubia", "sony", "lg", "google", "pixel", "huawei", "honor", "oneplus", "zte", "lenovo", "motorola", "nokia", "htc", "itel"];

    // --- SEEDED RANDOM CLASS (Ported from Python logic) ---
    class SeededRandom {
        constructor(seedStr) {
            this.seed = 0;
            for (let i = 0; i < seedStr.length; i++) {
                this.seed += seedStr.charCodeAt(i);
            }
        }
        
        // Linear Congruential Generator
        next() {
            this.seed = (this.seed * 9301 + 49297) % 233280;
            return this.seed / 233280;
        }

        choice(arr) {
            return arr[Math.floor(this.next() * arr.length)];
        }

        randint(min, max) {
            return Math.floor(this.next() * (max - min + 1)) + min;
        }
    }

    // --- AUDIO HANDLING ---
    const audio = document.getElementById('bg-music');
    audio.volume = 0.4; // 40% volume
    audio.loop = true;
    
    // Try to play on first interaction
    function playAudio() {
        audio.play().catch(e => console.log("Audio play failed (waiting for interaction):", e));
        document.removeEventListener('click', playAudio);
        document.removeEventListener('touchstart', playAudio);
    }
    document.addEventListener('click', playAudio);
    document.addEventListener('touchstart', playAudio);

    // --- UI INITIALIZATION ---
    // 1. Rainbow Header
    const headerText = "[ Oreki_Veritified ]";
    const headerEl = document.getElementById('rainbow-header');
    const headerChars = [];
    let headerHue = 0.0;

    for (let char of headerText) {
        let span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char;
        span.className = 'char';
        headerEl.appendChild(span);
        headerChars.push(span);
    }

    function animateHeader() {
        headerChars.forEach((span, i) => {
            let h = (headerHue - (i * 0.03)) % 1.0;
            if (h < 0) h += 1.0;
            // HSV to RGB conversion for CSS
            let s = 1.0, v = 1.0;
            let r, g, b, i_h, f, p, q, t;
            i_h = Math.floor(h * 6);
            f = h * 6 - i_h;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i_h % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            span.style.color = `rgb(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)})`;
        });
        headerHue += 0.01;
        if (headerHue > 1.0) headerHue -= 1.0;
        requestAnimationFrame(animateHeader);
    }
    animateHeader();

    // 2. Generate Mode Toggles
    const modesContainer = document.getElementById('modes-container');
    MODES.forEach(mode => {
        const div = document.createElement('div');
        div.className = 'mode-row';
        div.innerHTML = `
            <span>${mode.text}</span>
            <label class="switch">
                <input type="checkbox" id="chk-${mode.id}">
                <span class="slider"></span>
            </label>
        `;
        modesContainer.appendChild(div);
    });

    // --- LOADING SCREEN LOGIC (CANVAS) ---
    const canvas = document.getElementById('loading-canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let loadingProgress = 0;
    
    // Globe Data
    let globeLines = [];
    let globePoints = [];
    let globeAngle = 0.0;
    const globeRadius = 110;

    function initGlobeData() {
        globeLines = [];
        globePoints = [];
        
        // Meridians
        for (let lon = 0; lon < 360; lon += 15) {
            let line = [];
            for (let lat = -90; lat <= 90; lat += 5) {
                let phi = lat * Math.PI / 180;
                let theta = lon * Math.PI / 180;
                line.push({
                    x: globeRadius * Math.cos(phi) * Math.cos(theta),
                    y: globeRadius * Math.sin(phi),
                    z: globeRadius * Math.cos(phi) * Math.sin(theta)
                });
            }
            globeLines.push(line);
        }
        // Parallels
        for (let lat = -60; lat <= 60; lat += 20) {
            let line = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                let phi = lat * Math.PI / 180;
                let theta = lon * Math.PI / 180;
                line.push({
                    x: globeRadius * Math.cos(phi) * Math.cos(theta),
                    y: globeRadius * Math.sin(phi),
                    z: globeRadius * Math.cos(phi) * Math.sin(theta)
                });
            }
            globeLines.push(line);
        }

        // Continents (Random dots around centers)
        const continents = [
            {lat: 45, lon: -100, rad: 30}, // NA
            {lat: -20, lon: -60, rad: 25}, // SA
            {lat: 50, lon: 10, rad: 20},   // EU
            {lat: 10, lon: 20, rad: 30},   // AF
            {lat: 40, lon: 90, rad: 40},   // AS
            {lat: -25, lon: 135, rad: 20}  // AU
        ];
        continents.forEach(c => {
            for(let i=0; i<120; i++) {
                let lat = c.lat + (Math.random() * c.rad * 2 - c.rad);
                let lon = c.lon + (Math.random() * c.rad * 2 - c.rad);
                let phi = lat * Math.PI / 180;
                let theta = lon * Math.PI / 180;
                globePoints.push({
                    x: globeRadius * Math.cos(phi) * Math.cos(theta),
                    y: globeRadius * Math.sin(phi),
                    z: globeRadius * Math.cos(phi) * Math.sin(theta)
                });
            }
        });
    }

    // Matrix Effect Data
    let matrixStreams = [];
    
    function setupMatrix() {
        matrixStreams = [];
        const fontSize = 12;
        const columns = Math.floor(canvas.width / fontSize);
        for(let i=0; i<columns; i++) {
            matrixStreams.push({
                x: i * fontSize,
                y: Math.random() * -500,
                speed: Math.floor(Math.random() * 10) + 15, // Fast speed
                length: Math.floor(Math.random() * 20) + 10,
                chars: Array(30).fill(0).map(() => Math.random() > 0.5 ? '1' : '0')
            });
        }
    }

    function animateLoading() {
        // Resize canvas to full screen
        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            setupMatrix();
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const fontSize = 12;
        ctx.font = "bold 12px Consolas";

        // Draw Matrix
        matrixStreams.forEach(stream => {
            stream.y += stream.speed;
            if (stream.y - stream.length * fontSize > canvas.height) {
                stream.y = Math.random() * -200;
            }
            
            for(let i=0; i<stream.length; i++) {
                let charY = stream.y - i * fontSize;
                if (charY > 0 && charY < canvas.height) {
                    if (i === 0) {
                        ctx.fillStyle = "#00ff00"; // Head
                    } else {
                        ctx.fillStyle = "#003300"; // Tail
                    }
                    // Randomly flip bits
                    if (Math.random() > 0.95) stream.chars[i] = stream.chars[i] === '1' ? '0' : '1';
                    ctx.fillText(stream.chars[i], stream.x, charY);
                }
            }
        });

        // Draw Globe
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        globeAngle += 0.02;
        const cosA = Math.cos(globeAngle);
        const sinA = Math.sin(globeAngle);

        ctx.lineWidth = 1;
        ctx.strokeStyle = "#003300";

        // Lines
        globeLines.forEach(line => {
            ctx.beginPath();
            let first = true;
            line.forEach(p => {
                // Rotate Y
                let rx = p.x * cosA - p.z * sinA;
                let rz = p.x * sinA + p.z * cosA;
                // Project
                if (first) {
                    ctx.moveTo(cx + rx, cy + p.y);
                    first = false;
                } else {
                    ctx.lineTo(cx + rx, cy + p.y);
                }
            });
            ctx.stroke();
        });

        // Points (Continents)
        ctx.fillStyle = "#00ff00";
        globePoints.forEach(p => {
            let rx = p.x * cosA - p.z * sinA;
            let rz = p.x * sinA + p.z * cosA;
            if (rz > 0) { // Front facing only
                ctx.beginPath();
                ctx.arc(cx + rx, cy + p.y, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // Loading Bar
        const barWidth = 300;
        const barHeight = 10;
        const barX = cx - barWidth / 2;
        const barY = cy + 140;

        ctx.strokeStyle = "#00ff00";
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        const fillWidth = (loadingProgress / 100) * barWidth;
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(barX, barY, fillWidth, barHeight);

        ctx.textAlign = "center";
        ctx.fillText(`ANALYZING DATA... ${Math.min(100, Math.floor(loadingProgress))}%`, cx, barY + 25);
        ctx.esckAdi

        animationId = requestAnimationFrame(animateLoading);
    }

    // --- MAIN LOGIC ---
    async function startAnalysis() {
        if (audio.paused) {
            playAudio();
        }

        const deviceName = document.getElementById('device-input').value.trim();
        const currentSensVal = document.getElementById('current-sens').value.trim();
        const currentBtnVal = document.getElementById('current-btn-size').value.trim();
        
        if (!deviceName) {
            alert("Vui l√≤ng nh·∫≠p t√™n thi·∫øt b·ªã!");
            return;
        }

        const isBrandValid = VALID_BRANDS.some(brand => deviceName.toLowerCase().includes(brand));
        if (!isBrandValid) {
            alert("Thi·∫øt b·ªã kh√¥ng ƒë∆∞·ª£c nh·∫≠n di·ªán ho·∫∑c kh√¥ng ph·ªï bi·∫øn tr√™n th·ªã tr∆∞·ªùng!\nVui l√≤ng nh·∫≠p ƒë√∫ng t√™n d√≤ng m√°y (VD: Samsung S23, iPhone 11...)");
            return;
        }

        // Validate Sensitivity Input
        if (currentSensVal) {
            const sensParts = currentSensVal.split('-');
            if (sensParts.length !== 6) {
                alert("ƒê·ªãnh d·∫°ng ƒë·ªô nh·∫°y kh√¥ng ƒë√∫ng! Vui l√≤ng nh·∫≠p 6 s·ªë ngƒÉn c√°ch b·ªüi d·∫•u g·∫°ch ngang (-).\nV√≠ d·ª•: 100-100-100-100-50-50");
                return;
            }
            for (let val of sensParts) {
                const num = parseInt(val.trim());
                if (isNaN(num) || num < 0 || num > 200) {
                    alert(`Gi√° tr·ªã ƒë·ªô nh·∫°y "${val}" kh√¥ng h·ª£p l·ªá! Gi√° tr·ªã ph·∫£i n·∫±m trong kho·∫£ng 0-200.`);
                    return;
                }
            }
        }

        // Validate Button Size Input
        if (currentBtnVal) {
            const btnSize = parseInt(currentBtnVal);
            if (isNaN(btnSize) || btnSize < 1 || btnSize > 100) {
                alert("K√≠ch th∆∞·ªõc n√∫t b·∫Øn kh√¥ng h·ª£p l·ªá! Gi√° tr·ªã ph·∫£i n·∫±m trong kho·∫£ng 1-100.");
                return;
            }
        }

        // Disable UI
        const btn = document.getElementById('analyze-btn');
        btn.disabled = true;
        btn.style.backgroundColor = "#660000";
        btn.style.color = "#ff0000";
        document.getElementById('result-text').value = "";
        document.querySelector('.output-frame').classList.remove('has-result');

        // Show Loading
        const overlay = document.getElementById('loading-overlay');
        overlay.style.display = 'block';
        document.querySelector('.container').classList.add('blurred');
        initGlobeData();
        setupMatrix();
        loadingProgress = 0;
        animateLoading();

        // Simulate Processing (Async loop)
        for (let i = 1; i <= 100; i++) {
            loadingProgress = i;
            let delay = 15;
            if (i >= 40) delay = 25;
            if (i >= 80) delay = 40;
            await new Promise(r => setTimeout(r, delay));
        }
        await new Promise(r => setTimeout(r, 300)); // Pause at 100%

        // Stop Loading
        cancelAnimationFrame(animationId);
        overlay.style.display = 'none';
        document.querySelector('.container').classList.remove('blurred');

        // Calculate & Display
        const selectedModes = MODES.filter(m => document.getElementById(`chk-${m.id}`).checked).map(m => m.id);
        if (selectedModes.length === 0) selectedModes.push("stable");

        const config = calculateSensitivity(deviceName, selectedModes, currentSensVal, currentBtnVal);
        displayResult(config);

        // Reset UI
        document.getElementById('status-bar').textContent = "Analysis Complete.";
        btn.disabled = false;
        btn.style.backgroundColor = ""; // Reset to CSS default
        btn.style.color = "";
    }

    function calculateSensitivity(device, modes, curSensInput, curBtnInput) {
        const rng = new SeededRandom(device.toLowerCase());
        
        const isIos = ['iphone', 'ipad', 'ios'].some(x => device.toLowerCase().includes(x));
        const isHighEnd = ['pro', 'ultra', 'plus', 'max', 's2', 'rog', 'black shark'].some(x => device.toLowerCase().includes(x));

        let baseDpi, dpiLabel;
        if (isIos) {
            baseDpi = rng.choice([31, 120]);
            dpiLabel = "Gi√° tr·ªã con tr·ªè tr∆∞·ª£t (Sliding Cursor)";
        } else {
            if (modes.includes("oneshot") || modes.includes("light")) {
                baseDpi = rng.choice([581, 600, 720, 800]);
            } else if (modes.includes("recoil")) {
                baseDpi = rng.choice([411, 440, 480]);
            } else {
                baseDpi = rng.choice([480, 500, 550]);
            }
            dpiLabel = "DPI (ƒê·ªô r·ªông t·ªëi thi·ªÉu)";
        }

        let sensGeneral = rng.randint(185, 200);
        let sensRedDot = rng.randint(175, 195);
        let sens2x = rng.randint(165, 185);
        let sens4x = rng.randint(155, 175);
        let sensSniper = rng.randint(60, 80);
        let sensLook = rng.randint(120, 160);
        let buttonSize = rng.randint(45, 55);
        let buttonPosNote = "K√©o th·∫•p xu·ªëng d∆∞·ªõi 10%"; // Default

        let notes = [];
        notes.push(`AI nh·∫≠n di·ªán thi·∫øt b·ªã: ${isHighEnd ? 'High-End (M√†n h√¨nh t·∫ßn s·ªë qu√©t cao)' : 'Standard (C·∫ßn t·ªëi ∆∞u ƒë·ªô tr·ªÖ)'}.`);

        let graphicsSetting = "Th·∫•p (Smooth)";
        let fpsSetting = "Cao (High)";
        let shadows = "T·∫Øt (Off)";

        // --- LOGIC D·ª∞A TR√äN INPUT NG∆Ø·ªúI D√ôNG ---
        // Parse 6 values: Gen-Red-2x-4x-Snip-Look
        let userSens = [];
        if (curSensInput && curSensInput.includes('-')) {
            userSens = curSensInput.split('-').map(s => parseInt(s.trim()));
        }
        
        let userBtn = parseInt(curBtnInput);

        // Apply User Input if valid (6 values)
        if (userSens.length === 6 && !userSens.some(isNaN)) {
            sensGeneral = userSens[0];
            sensRedDot = userSens[1];
            sens2x = userSens[2];
            sens4x = userSens[3];
            sensSniper = userSens[4];
            sensLook = userSens[5];
        }

        // Logic Nh·∫π T√¢m (Light Touch)
        if (modes.includes("light")) {
            if (userSens.length === 6) {
                sensGeneral = Math.floor(sensGeneral * 1.05);
                sensRedDot = Math.floor(sensRedDot * 1.05);
                sens2x = Math.floor(sens2x * 1.05);
                sens4x = Math.floor(sens4x * 1.05);
                sensSniper = Math.floor(sensSniper * 1.05);
                sensLook = Math.floor(sensLook * 1.05);
            } else {
                sensGeneral = 200; // Default max if no input
            }

            if (!isNaN(userBtn)) {
                buttonSize = Math.max(10, Math.floor(userBtn * 0.9)); // Gi·∫£m nh·ªè n√∫t b·∫Øn
            } else {
                buttonSize = rng.randint(38, 45);
            }
            buttonPosNote = "H·∫° th·∫•p v·ªã tr√≠ n√∫t b·∫Øn xu·ªëng th√™m 5-10% so v·ªõi hi·ªán t·∫°i";
            notes.push("üí° M·∫πo t·ª´ Ruok FF/White444: V·ªõi ƒë·ªô nh·∫°y cao, h√£y ƒë·∫∑t ng√≥n tay c√°i th·∫•p h∆°n ƒë·ªÉ h√†nh tr√¨nh vu·ªët t√¢m d√†i h∆°n, gi√∫p t√¢m b·∫Øt ƒë·∫ßu nhanh h∆°n.");
        }

        // Logic Gi·∫£m L·ªë (Reduce Overshoot)
        if (modes.includes("overshoot")) {
            if (userSens.length === 6) {
                sensGeneral = Math.floor(sensGeneral * 0.9);
                sensRedDot = Math.floor(sensRedDot * 0.85); // Reduce more
                sens2x = Math.floor(sens2x * 0.9);
                sens4x = Math.floor(sens4x * 0.9);
                sensSniper = Math.floor(sensSniper * 0.9);
                sensLook = Math.floor(sensLook * 0.9);
            } else {
                sensGeneral = Math.floor(sensGeneral * 0.9);
                sensRedDot = Math.floor(sensRedDot * 0.8);
            }

            if (!isNaN(userBtn)) {
                buttonSize = Math.min(100, Math.floor(userBtn * 1.1)); // TƒÉng k√≠ch th∆∞·ªõc n√∫t b·∫Øn
            } else {
                buttonSize = rng.randint(55, 65);
            }
            buttonPosNote = "K√©o v·ªã tr√≠ n√∫t b·∫Øn cao l√™n m·ªôt ch√∫t ƒë·ªÉ kh√≥a t√¢m t·ªët h∆°n";
            notes.push("üí° L∆∞u √Ω: N·∫øu t√¢m th∆∞·ªùng xuy√™n bay qua ƒë·∫ßu, h√£y gi·∫£m Red Dot xu·ªëng 5-10 ƒë∆°n v·ªã. K√©o n√∫t b·∫Øn cao l√™n gi√∫p kh√≥a t√¢m ch·∫Øc h∆°n.");
        }

        // C√°c logic kh√°c
        if (modes.includes("recoil")) {
            sens2x = rng.randint(130, 150);
            sens4x = rng.randint(110, 130);
            notes.push("üí° Kinh nghi·ªám B2K: Khi s√∫ng b·ªã rung (recoil), h√£y th·ª≠ ng·ªìi xu·ªëng ho·∫∑c n·∫±m ra ƒë·ªÉ t√¢m s√∫ng h·ªìi l·∫°i nhanh h∆°n. Gi·∫£m ƒë·ªô nh·∫°y Scope gi√∫p gh√¨m t√¢m t·ªët h∆°n.");
        }

        if (modes.includes("oneshot")) {
            sensGeneral = 200; sensRedDot = 200; sens2x = 200; sens4x = 200; sensLook = 200;
            sensSniper = rng.randint(100, 150);
            buttonSize = rng.randint(35, 42);
            notes.push("üí° Phong c√°ch Raistar/Nobru: S·ª≠ d·ª•ng n√∫t b·∫Øn nh·ªè v√† DPI cao ƒë·ªÉ th·ª±c hi·ªán c√°c pha v·∫©y t√¢m ch·ªØ J ho·∫∑c U c·ª±c nhanh.");
        }

        if (modes.includes("fps")) {
            graphicsSetting = "Th·∫•p (Smooth)";
            fpsSetting = "Cao/Ultra (High)";
            shadows = "T·∫Øt (Off)";
            notes.push("üí° T·ªëi ∆∞u h√≥a: ∆Øu ti√™n FPS cao nh·∫•t (High/Ultra) ƒë·ªÉ gi·∫£m ƒë·ªô tr·ªÖ input, gi√∫p ph·∫£n x·∫° nhanh h∆°n trong giao tranh.");
        }

        if (modes.includes("graphics")) {
            graphicsSetting = "Max (Ultra)";
            fpsSetting = "Cao (High)";
            shadows = "B·∫≠t (On)";
            notes.push("üí° T·ªëi ∆∞u h√≥a: B·∫≠t max ƒë·ªì h·ªça gi√∫p nh√¨n r√µ ƒë·ªãch ·ªü xa h∆°n, ph√π h·ª£p cho c√°c d√≤ng m√°y c·∫•u h√¨nh m·∫°nh.");
        }

        if (modes.includes("stable") && modes.length === 1) {
            notes.push("üí° C·∫•u h√¨nh c√¢n b·∫±ng (Standard Competitive): Ph√π h·ª£p cho c·∫£ leo rank v√† b·∫Øn gi·∫£i, gi·ªØ ƒë·ªô ·ªïn ƒë·ªãnh cao nh·∫•t.");
        }

        // Clamp
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
        sensGeneral = clamp(sensGeneral, 0, 200);
        sensRedDot = clamp(sensRedDot, 0, 200);
        sens2x = clamp(sens2x, 0, 200);
        sens4x = clamp(sens4x, 0, 200);
        sensSniper = clamp(sensSniper, 0, 200);
        sensLook = clamp(sensLook, 0, 200);

        // Radar Stats
        let speedScore = rng.randint(65, 80);
        let aimScore = rng.randint(65, 80);
        let stabilityScore = rng.randint(65, 80);

        if (modes.includes("light")) { speedScore += 15; stabilityScore -= 10; }
        if (modes.includes("oneshot")) { speedScore += 20; aimScore -= 5; stabilityScore -= 15; }
        if (modes.includes("recoil")) { stabilityScore += 20; aimScore += 10; speedScore -= 10; }
        if (modes.includes("stable")) { stabilityScore += 15; aimScore += 5; }
        if (modes.includes("overshoot")) { aimScore += 15; speedScore -= 5; }
        if (modes.includes("fps")) { speedScore += 5; }

        return {
            device: device,
            modes: modes.join(", ").toUpperCase(),
            dpi: baseDpi,
            dpiLabel: dpiLabel,
            general: sensGeneral,
            redDot: sensRedDot,
            x2: sens2x,
            x4: sens4x,
            sniper: sensSniper,
            look: sensLook,
            button: buttonSize,
            buttonPos: buttonPosNote,
            graphics: graphicsSetting,
            fps: fpsSetting,
            shadows: shadows,
            note: notes.join(" + "),
            speed: clamp(speedScore, 10, 100),
            aim: clamp(aimScore, 10, 100),
            stability: clamp(stabilityScore, 10, 100)
        };
    }

    function displayResult(config) {
        function drawBar(val) {
            const filled = Math.floor(val / 10);
            return "‚ñ†".repeat(filled) + "‚ñ°".repeat(10 - filled);
        }

        const output = `
================================================
   K·∫æT QU·∫¢ T·ªêI ∆ØU H√ìA: ${config.device.toUpperCase()}
================================================

[ TH√îNG S·ªê H·ªÜ TH·ªêNG ]
> Ch·∫ø ƒë·ªô: ${config.modes}
> ${config.dpiLabel}: ${config.dpi}
> T·ªëc ƒë·ªô con tr·ªè: M·ª©c 7 (M·∫∑c ƒë·ªãnh)

[ ƒê·ªò NH·∫†Y FREE FIRE MAX (0-200) ]
> Nh√¨n xung quanh:      ${config.general}
> ·ªêng ng·∫Øm h·ªìng t√¢m:    ${config.redDot}
> ·ªêng ng·∫Øm 2x:          ${config.x2}
> ·ªêng ng·∫Øm 4x:          ${config.x4}
> ·ªêng ng·∫Øm s√∫ng ng·∫Øm:   ${config.sniper}
> N√∫t camera t·ª± do:     ${config.look}

[ ƒê·ªí H·ªåA & FPS ]
> ƒê·ªì h·ªça:           ${config.graphics}
> FPS:              ${config.fps}
> B√≥ng ƒë·ªï:          ${config.shadows}

[ HUD CONTROL ]
> K√≠ch th∆∞·ªõc n√∫t b·∫Øn: ${config.button}%
> V·ªã tr√≠ n√∫t b·∫Øn:     ${config.buttonPos}

[ BI·ªÇU ƒê·ªí CH·ªà S·ªê (RADAR) ]
SPEED     : ${drawBar(config.speed)} (${config.speed})
AIM       : ${drawBar(config.aim)} (${config.aim})
STABILITY : ${drawBar(config.stability)} (${config.stability})

[ L·ªúI KHUY√äN T·ª™ OREKI ]
> ${config.note}

Mua file ib zalo 0336514635
================================================
Generated by Oreki_Veritified
`;
        document.getElementById('result-text').value = output.trim();
        document.querySelector('.output-frame').classList.add('has-result');
    }

    // --- BACKGROUND ANIMATION (Thicker & Brighter) ---
    const bgCanvas = document.getElementById('bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    let bgParticles = [];
    
    // Mouse Interaction
    let mouse = { x: null, y: null };
    window.addEventListener('mousemove', (e) => { mouse.x = e.x; mouse.y = e.y; });
    window.addEventListener('touchmove', (e) => { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }, {passive: true});

    function resizeBg() {
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        initBg();
    }
    window.addEventListener('resize', resizeBg);

    class Particle {
        constructor() {
            this.x = Math.random() * bgCanvas.width;
            this.y = Math.random() * bgCanvas.height;
            this.vx = (Math.random() - 0.5) * 1.5;
            this.vy = (Math.random() - 0.5) * 1.5;
            this.size = Math.random() * 2 + 1;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < 0 || this.x > bgCanvas.width) this.vx *= -1;
            if (this.y < 0 || this.y > bgCanvas.height) this.vy *= -1;
        }
    }

    function initBg() {
        bgParticles = [];
        // High density: 1 particle per 3000px
        const count = Math.floor((window.innerWidth * window.innerHeight) / 3000); 
        for (let i = 0; i < count; i++) bgParticles.push(new Particle());
    }

    function animateBg() {
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        for (let i = 0; i < bgParticles.length; i++) {
            let p = bgParticles[i];
            p.update();
            
            // Draw Dot
            bgCtx.fillStyle = "rgba(0, 255, 0, 0.6)";
            bgCtx.beginPath(); bgCtx.arc(p.x, p.y, p.size, 0, Math.PI*2); bgCtx.fill();
            
            // Draw Lines
            for (let j = i + 1; j < bgParticles.length; j++) {
                let p2 = bgParticles[j];
                let d = (p.x - p2.x)**2 + (p.y - p2.y)**2;
                if (d < 10000) { // Connect closer particles
                    bgCtx.strokeStyle = `rgba(0, 255, 0, ${0.5 * (1 - d/10000)})`;
                    bgCtx.lineWidth = 0.5;
                    bgCtx.beginPath(); bgCtx.moveTo(p.x, p.y); bgCtx.lineTo(p2.x, p2.y); bgCtx.stroke();
                }
            }
            // Mouse Connect
            if (mouse.x != null) {
                let d = (p.x - mouse.x)**2 + (p.y - mouse.y)**2;
                if (d < 20000) {
                    bgCtx.strokeStyle = `rgba(0, 255, 0, ${0.8 * (1 - d/20000)})`;
                    bgCtx.lineWidth = 0.8;
                    bgCtx.beginPath(); bgCtx.moveTo(p.x, p.y); bgCtx.lineTo(mouse.x, mouse.y); bgCtx.stroke();
                }
            }
        }
        requestAnimationFrame(animateBg);
    }
    resizeBg();
    animateBg();

    // --- OUTPUT BOX ANIMATION (Tech HUD) ---
    const outCanvas = document.getElementById('output-canvas');
    const outCtx = outCanvas.getContext('2d');
    let outFrame = 0;

    function resizeOutCanvas() {
        if(outCanvas.parentElement) {
            outCanvas.width = outCanvas.parentElement.clientWidth;
            outCanvas.height = outCanvas.parentElement.clientHeight;
        }
    }
    window.addEventListener('resize', resizeOutCanvas);

    function drawTechHUD() {
        outCtx.clearRect(0, 0, outCanvas.width, outCanvas.height);
        outFrame++;
        const w = outCanvas.width;
        const h = outCanvas.height;

        // 1. Grid
        outCtx.strokeStyle = "rgba(0, 255, 0, 0.15)";
        outCtx.lineWidth = 1;
        const gridSize = 40;
        const offsetY = (outFrame * 0.5) % gridSize;
        
        for(let x=0; x<w; x+=gridSize) {
            outCtx.beginPath(); outCtx.moveTo(x, 0); outCtx.lineTo(x, h); outCtx.stroke();
        }
        for(let y=offsetY; y<h; y+=gridSize) {
            outCtx.beginPath(); outCtx.moveTo(0, y); outCtx.lineTo(w, y); outCtx.stroke();
        }

        // 2. Scanning Line
        const scanY = (outFrame * 2) % h;
        outCtx.strokeStyle = "rgba(0, 255, 0, 0.6)";
        outCtx.lineWidth = 2;
        outCtx.beginPath(); outCtx.moveTo(0, scanY); outCtx.lineTo(w, scanY); outCtx.stroke();
        
        // 3. Rotating Target
        const cx = w/2;
        const cy = h/2;
        outCtx.save();
        outCtx.translate(cx, cy);
        outCtx.rotate(outFrame * 0.02);
        outCtx.strokeStyle = "rgba(0, 255, 0, 0.4)";
        outCtx.setLineDash([15, 10]);
        outCtx.beginPath(); outCtx.arc(0, 0, 60, 0, Math.PI*2); outCtx.stroke();
        outCtx.restore();

        requestAnimationFrame(drawTechHUD);
    }
    // Init Output Animation
    setTimeout(() => {
        resizeOutCanvas();
        drawTechHUD();
    }, 100);

    document.getElementById('analyze-btn').addEventListener('click', startAnalysis);
});
</script>

</body>
</html>
